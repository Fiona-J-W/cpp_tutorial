<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <style type="text/css">
  body {
  	max-width: 20cm;
  	margin-left: auto;
  	margin-right: auto;
  	text-align: justify;
  }
  @media screen {
  	body {
  		font-family: sans;
  	}
  }
  @media print {
  	body {
  		font-family: serif;
  	}
  }
  
  h1, h2, h3, h4, h5, h6 {
  	font-family: sans;
  }
  
  h1 {
  	text-align: center;
  	border-bottom: 2px solid gray;
  }
  
  h2 {
  	margin-top: 1cm;
  	border-bottom: 2px dotted gray;
  }
  
  blockquote {
  	background-color: #fbfbfb;
  	padding: 0.3cm;
  	border-radius: 0.2cm;
  	border-color: blue;
  	border-style: solid;
  	border-width: 2px;
  	margin-left: 0;
  	margin-right: 0;
  	font-style: italic;
  }
  
  code {
  	font-size: 125%;
  }
  
  pre.sourceCode {
  	background-color: #fbfbfb;
  	padding: 0.3cm;
  	border-radius: 0.2cm;
  	border-color: green;
  	border-style: solid;
  	border-width: 2px;
  }
  
  pre.output {
  	background-color: #fbfbfb;
  	padding: 0.3cm;
  	border-radius: 0.2cm;
  	border-color: blue;
  	border-style: solid;
  	border-width: 2px;
  }
  
  a.footnoteRef {
  	text-decoration: none;
  	color: blue;
  }
  
  figure > img {
  	width: 100%;
  	height: auto;
  }
  
  section.license {
  	font-size: 90%;
  	color: gray;
  }
  
  section.license > a {
  	color: gray;
  }
  
  </style>
</head>
<body>
<h1 id="functions">Functions</h1>
<p>A function is a construct available in virtually all programming languages. By the simplest definition, functions are reusable snippets of code. Reducing repetition is the main purpose of functions; doing so makes the code better understandable and reduces the chance of errors.</p>
<p>It's perhaps best to start describing functions by a simple example: Let's say we have a vector of ints and we want to find the biggest element. The code to accomplish this is pretty simple:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>

<span class="dt">int</span> main() {
	std::vector&lt;<span class="dt">int</span>&gt; vec {<span class="dv">5</span>, <span class="dv">-3</span>, <span class="dv">2</span>, <span class="dv">7</span>, <span class="dv">11</span>};
	
	<span class="kw">auto</span> smallest_element = vec[<span class="dv">0</span>];
	<span class="kw">for</span> (<span class="kw">auto</span> x: vec) {
		<span class="kw">if</span> (x&lt;smallest_element) {
			smallest_element = x;
		} 
	}
	std::cout &lt;&lt; <span class="st">&quot;smallest element is &quot;</span> &lt;&lt; smallest_element &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;
}</code></pre>
<pre><code>&gt;&gt; smallest element of vec is -3</code></pre>
<p>This solution works, but the problem is, that every time we want to do this again, we have to write those lines again, which is unpleasant at best but most likely also error-prone. Functions give us the flexibility to avoid rewriting this:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>

<span class="dt">int</span> smallest_element(std::vector&lt;<span class="dt">int</span>&gt; vec) {
	<span class="kw">auto</span> smallest_value = vec[<span class="dv">0</span>];
	<span class="kw">for</span> (<span class="kw">auto</span> x: vec) {
		<span class="kw">if</span> (x&lt;smallest_value) {
			smallest_value = x;
		}
	}
	<span class="kw">return</span> smallest_value;
}

<span class="dt">int</span> main() {
	std::vector&lt;<span class="dt">int</span>&gt; vec1 {<span class="dv">5</span>, <span class="dv">-3</span>, <span class="dv">2</span>, <span class="dv">7</span>, <span class="dv">11</span>};
	std::vector&lt;<span class="dt">int</span>&gt; vec2 {<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>};
	
	std::cout &lt;&lt; <span class="st">&quot;smallest element of vec1 is &quot;</span>
	          &lt;&lt; smallest_element(vec1) &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>
	          &lt;&lt; <span class="st">&quot;smallest element of vec2 is &quot;</span>
	          &lt;&lt; smallest_element(vec2) &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;
}</code></pre>
<pre><code>&gt;&gt; smallest element of vec1 is -3
&gt;&gt; smallest element of vec2 is 0</code></pre>
<p>The amount of saved typing is obvious. We also have the advantage that we are now able to improve the algorithm in one place so that the improvements are right away in the whole program.</p>
<h2 id="the-signature-of-a-function">The signature of a function</h2>
<p>Now: How does this work? Let's look at the first line of the function:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> smallest_element(std::vector&lt;<span class="dt">int</span>&gt; vec)</code></pre>
<p>This is called the functions signature. It consists of three parts: The name of the function (<code>smallest_element</code>), it's returntype (<code>int</code>) and a comma-separated list of it's arguments.</p>
<p>The name is probably the easiest part to understand: It identifies the function. The same restrictions that exist for variable names (may not start with a digit, may not contain whitespace or special characters other than underscore, …) apply also for names of functions.</p>
<p>The returntype is the type of the thing, that a function returns. We gave it a vector of ints and request the smallest element, so the returntype is of course int. If there is nothing to return, the returntype is <code>void</code>.</p>
<p>The arguments are the data on which the function should operate. Since we want to inspect a vector of ints it has to get into the function somehow, so we pass it as argument. The list may be empty, in which case we just write <code>()</code>; otherwise we write the type of the argument, followed by the name with which we refer to it in the function. If their are further arguments they have to be written in the same way, divided by commas.</p>
<h2 id="the-body-of-a-function">The body of a function</h2>
<p>Since we should now have a basic idea of how the signature works we can examine the rest of it, the so called body:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">{
	<span class="kw">auto</span> smallest_value = vec[<span class="dv">0</span>];
	<span class="kw">for</span> (<span class="kw">auto</span> x: vec) {
		<span class="kw">if</span> (x&lt;smallest_value) {
			smallest_value = x;
		}
	}
	<span class="kw">return</span> smallest_value;
}</code></pre>
<p>The first thing that should be noted are the braces that start and end the function. They also create a new scope so that every variable in it only exists in the function.</p>
<p>The first five lines inside that scope are pretty normal C++ without any real surprises.</p>
<p>The last line however contains a so called return-statement. It consists of the word <code>return</code> followed by whitespace, followed by a statement that has a type, followed by a semicolon. „statement followed by a type“ mainly refers to either a literal, a variable, a call to a function that returns a value or some term that involves operators (which can be seen as functions). So all of these are valid return-statements:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// literal 1:</span>
<span class="kw">return</span> <span class="dv">1</span>;

<span class="co">// variable:</span>
<span class="dt">int</span> returnvalue = <span class="dv">2</span>;
<span class="kw">return</span> returnvalue;

<span class="co">// the result of some calculations involving operators:</span>
<span class="kw">return</span> <span class="dv">2</span>*<span class="dv">3</span> + <span class="dv">4</span>*<span class="dv">5</span>;

<span class="co">// the returnvalue of some function:</span>
<span class="kw">return</span> some_function(<span class="dv">1</span>, <span class="dv">3</span>);</code></pre>
<p>It is important that the type of the used expression is either identical to the returntype of the function or can be trivially converted to it:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span> fun_1() {
	<span class="kw">return</span> <span class="fl">1.</span><span class="dv">0</span>;
	<span class="co">// fine: 1.0 is double, as is the returntype of</span>
	<span class="co">// the function.</span>
}

<span class="dt">double</span> fun_2() {
	<span class="kw">return</span> <span class="dv">1</span>;
	<span class="co">// fine too: while 1 has type int, it can be trivially</span>
	<span class="co">// converted to double.</span>
}

<span class="dt">double</span> fun_3() {
	<span class="kw">return</span> <span class="st">&quot;some string&quot;</span>;
	<span class="co">// error: a string-literal cannot be trivially converted</span>
	<span class="co">// to double.</span>
}</code></pre>
<h2 id="calling-a-function">Calling a Function</h2>
<p>Calling a function is probably the easiest part in this chapter: Just write the name of the function followed by parenthesis that contain the arguments. Note that the arguments are copied into the function, so any changes that are made to them there wont change the value of the argument at the callside.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="ot">#include &lt;iostream&gt;</span>

<span class="dt">void</span> print_string(std::string str) {
	std::cout &lt;&lt; str &lt;&lt; std::endl;
}

<span class="dt">void</span> print_ints(<span class="dt">int</span> i1, <span class="dt">int</span> i2) {
	std::cout &lt;&lt; i1 &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; i2 &lt;&lt; std::endl;
}

<span class="dt">void</span> print_hello_world() {
	std::cout &lt;&lt; <span class="st">&quot;Hello World!&quot;</span> &lt;&lt; std::endl;
}

<span class="dt">int</span> main() {
	print_string(<span class="st">&quot;some string&quot;</span>);
	print_ints(<span class="dv">1</span>, <span class="dv">3</span>);
	print_hello_world();
}
</code></pre>
<pre><code>&gt;&gt; some string
&gt;&gt; 1, 3
&gt;&gt; Hello World!</code></pre>
<p>If we are interested in the returnvalue, we can just use the call as if it would be a value:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>

<span class="dt">int</span> add(<span class="dt">int</span> i1, <span class="dt">int</span> i2) {
	<span class="kw">return</span> i1 + i2;
}

<span class="co">// implemented according to http://xkcd.com/221/</span>
<span class="dt">int</span> get_random_number() {
	<span class="co">//chosen by fair dice-roll:</span>
	<span class="kw">return</span> <span class="dv">4</span>;
}

<span class="dt">int</span> main() {
	<span class="dt">int</span> a = add(<span class="dv">1</span>,<span class="dv">2</span>);
	std::cout &lt;&lt; <span class="st">&quot;The value of a is &quot;</span> &lt;&lt; a &lt;&lt; <span class="st">&quot;.</span><span class="ch">\n</span><span class="st">&quot;</span>
	          &lt;&lt; <span class="st">&quot;A truly random number is: &quot;</span>
	          &lt;&lt; get_random_number() &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;
}</code></pre>
<pre><code>&gt;&gt; The value of a is 3.
&gt;&gt; A truly random number is: 4.</code></pre>
<h2 id="some-examples">Some examples</h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>

<span class="co">// a function that takes no arguments and returns</span>
<span class="co">// an int:</span>
<span class="dt">int</span> function_1() {
	<span class="kw">return</span> <span class="dv">1</span>;
}

<span class="co">// a function that prints an int that is passed to it and</span>
<span class="co">// returns nothing:</span>
<span class="dt">void</span> print_int(<span class="dt">int</span> n) {
	std::cout &lt;&lt; n &lt;&lt; std::endl;
}

<span class="co">// a function that returns nothing, takes no arguments and</span>
<span class="co">// does nothing:</span>
<span class="dt">void</span> do_nothing() {}</code></pre>
<h2 id="function-overloading">Function Overloading</h2>
<p>TODO: rewrite this text</p>
<p>After having learned about both <code>const</code> and references, we now know enough about passing arguments into functions to get pretty far. While there are some (relatively strange) other ways of doing that, the importance for most programmers to know about them is very small, as they are mainly relevant to those people who implement C++ itself. Since we are currently far away from doing this, we'll move that topic to the distant future and instead take a look at something that is useful for everyone instead: Overloading functions.</p>
<p>Careful readers may have noticed in the introduction to functions, that the naming-requirements did not explicitly include, that the name has to be unique. That is because it isn't. Functions are identified not only by their names, but also by their arguments. If the arguments of two functions differ in number or type it is valid for them to share a name.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>

<span class="dt">void</span> function(<span class="dt">int</span> n) {
	std::cout &lt;&lt; <span class="st">&quot;function(int &quot;</span> &lt;&lt; n &lt;&lt; <span class="st">&quot;);</span><span class="ch">\n</span><span class="st">&quot;</span>;
}

<span class="dt">void</span> function(<span class="dt">double</span> d) {
	std::cout &lt;&lt; <span class="st">&quot;function(double &quot;</span> &lt;&lt; d &lt;&lt; <span class="st">&quot;);</span><span class="ch">\n</span><span class="st">&quot;</span>;
}

<span class="dt">int</span> main() {
	function(<span class="dv">3</span>);
	function(<span class="fl">2.</span><span class="dv">718</span>);
}</code></pre>
<pre><code>&gt;&gt; function(int 3);
&gt;&gt; function(double 2.718);</code></pre>
<!---Revisiting `smallest_element()`
-->

<p>In order to get used to this technique, we'll revisit our old companion <code>smallest_element()</code>. While the current version is already pretty good, we might be interested in a related but not identical function for strings: Find the smallest character. In order to keep this somewhat interesting, we'll define that a lowercase character is always smaller than an uppercase one and characters that come earlier in the alphabet are smaller than those that come later.</p>
<p>To keep this task manageable, we'll restrict ourselves to the characters of the English alphabet and ignore all other ones. Let's take a look at the code:</p>
<!---TODO: Should discourage passing containers, such as std::vector, as they have other templated
parameters which you would have to account for.-->

<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;locale&gt; </span><span class="co">// required for isupper and islower</span>

<span class="co">// the old version for vectors of ints</span>
<span class="dt">int</span> smallest_element(<span class="dt">const</span> std::vector&lt;<span class="dt">int</span>&gt;&amp; vec) {
	<span class="kw">auto</span> smallest_value = vec[<span class="dv">0</span>];
	<span class="kw">for</span> (<span class="kw">auto</span> x: vec) {
		<span class="kw">if</span> (x&lt;smallest_value) {
			smallest_value = x;
		}
	}
	<span class="kw">return</span> smallest_value;
}

<span class="co">// the new version for strings</span>
<span class="co">// return 0 if no character is found</span>
<span class="dt">char</span> smallest_element(<span class="dt">const</span> std::string&amp; str) {
	std::locale l{}; <span class="co">// required for isupper and islower</span>
	<span class="dt">char</span> smallest_char = <span class="dv">0</span>;
	<span class="dt">bool</span> result_is_lowercase = <span class="kw">false</span>;
	<span class="kw">for</span> (<span class="dt">char</span> c: str) {
		<span class="kw">if</span> (std::islower(c, l)) {
			<span class="kw">if</span>(smallest_char == <span class="dv">0</span> || !result_is_lowercase || c &lt; smallest_char) {
				smallest_char = c;
				result_is_lowercase = <span class="kw">true</span>;
			}
		}
		<span class="kw">else</span> <span class="kw">if</span> (!result_is_lowercase &amp;&amp; std::isupper(c, l)) {
			<span class="kw">if</span>(smallest_char == <span class="dv">0</span> <span class="kw">or</span> c &lt; smallest_char) {
				smallest_char = c;
			}
		}
	}
	<span class="kw">return</span> smallest_char;
}

<span class="dt">int</span> main() {
	std::cout &lt;&lt; <span class="st">&quot;the smallest character of &#39;Foobar&#39; is &#39;&quot;</span>
	          &lt;&lt; smallest_element(<span class="st">&quot;Foobar&quot;</span>) &lt;&lt; <span class="st">&#39;&#39;</span>\n<span class="st">&#39;</span>
	          &lt;&lt; <span class="st">&quot;the smallest number of 1, 3, 6, -3, 4 and 2 is: &quot;</span>
	          &lt;&lt; smallest_element(std::vector&lt;<span class="dt">int</span>&gt;{<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">6</span>, <span class="dv">-3</span>, <span class="dv">4</span>, <span class="dv">2</span>})
	          &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;
}</code></pre>
<pre><code>&gt;&gt; the smallest character of &#39;Foobar&#39; is &#39;a&#39;
&gt;&gt; the smallest number of 1, 3, 6, -3, 4 and 2 is: -3</code></pre>
<p>While the new code may not be very beautiful, it shows that there is no problem with creating two different functions that share a name and an abstract behavior (finding the smallest element in some kind of list) but differ in implementation.</p>
<hr/>
<section class="license">
	<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
		<img src="CC_BY_SA.png" height="31px" width="88px" alt="CC-BY-SA" align="left" hspace="2px"/>
	</a>
	This work from Florian Weber is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br/>
</section>
</body>
</html>
