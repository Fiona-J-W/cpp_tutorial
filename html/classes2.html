<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <style type="text/css">
  body {
  	max-width: 20cm;
  	margin-left: auto;
  	margin-right: auto;
  	text-align: justify;
  }
  @media screen {
  	body {
  		font-family: sans;
  	}
  }
  @media print {
  	body {
  		font-family: serif;
  	}
  }
  
  h1, h2, h3, h4, h5, h6 {
  	font-family: sans;
  }
  
  h1 {
  	text-align: center;
  	border-bottom: 2px solid gray;
  }
  
  h2 {
  	margin-top: 1cm;
  	border-bottom: 2px dotted gray;
  }
  
  blockquote {
  	background-color: #fbfbfb;
  	padding: 0.3cm;
  	border-radius: 0.2cm;
  	border-color: blue;
  	border-style: solid;
  	border-width: 2px;
  	margin-left: 0;
  	margin-right: 0;
  	font-style: italic;
  }
  
  code {
  	font-size: 125%;
  }
  
  pre.sourceCode {
  	background-color: #fbfbfb;
  	padding: 0.3cm;
  	border-radius: 0.2cm;
  	border-color: green;
  	border-style: solid;
  	border-width: 2px;
  }
  
  pre.output {
  	background-color: #fbfbfb;
  	padding: 0.3cm;
  	border-radius: 0.2cm;
  	border-color: blue;
  	border-style: solid;
  	border-width: 2px;
  }
  
  a.footnoteRef {
  	text-decoration: none;
  	color: blue;
  }
  
  figure > img {
  	width: 100%;
  	height: auto;
  }
  
  section.license {
  	font-size: 90%;
  	color: gray;
  }
  
  section.license > a {
  	color: gray;
  }
  
  </style>
</head>
<body>
<h1 id="datatypes">Datatypes</h1>
<p>In this chapter we will write a simple text-game in which we will visit a deep dungeon to search for great treasures and to fight evil monsters and even more evil competitors. Along the way we will learn how to create our very own datatypes and also make ourselves familiar with some further stdlib-functionality.</p>
<h2 id="preparing-the-loot-enums-and-structs">Preparing the Loot: Enums and Structs</h2>
<p>Starting with the creation of a player is boring, if we could instead be creating our freakingly-huge-sword-of-doom, so let's get to the loot first!</p>
<p>In our dungeon we expect four kinds of loot: Armor, weapons, jewelry and junk. We could now use an integer and some global constants to anotate what each item is, but the nice thing is that C++ already provides this in a more convenient way as a so called enum:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">enum</span> <span class="kw">class</span> item_kind {
	armor,
	weapon,
	jewelry,
	junk
};

std::string to_string(<span class="dt">const</span> item_kind&amp; kind) {
	<span class="kw">if</span> (kind == item_kind::armor) {
		<span class="kw">return</span> <span class="st">&quot;armor&quot;</span>;
	} <span class="kw">else</span> <span class="kw">if</span> (kind == item_kind::weapon) {
		<span class="kw">return</span> <span class="st">&quot;weapon&quot;</span>;
	} <span class="kw">else</span> <span class="kw">if</span> (kind == item_kind::jewelry) {
		<span class="kw">return</span> <span class="st">&quot;jewelry&quot;</span>;
	} <span class="kw">else</span> <span class="kw">if</span> (kind == item_kind::junk) {
		<span class="kw">return</span> <span class="st">&quot;junk&quot;</span>;
	} <span class="kw">else</span> {
		std::cerr &lt;&lt; <span class="st">&quot;This should never happen!</span><span class="ch">\n</span><span class="st">&quot;</span>;
		std::terminate();
	}
}

<span class="dt">int</span> main() {
	<span class="dt">const</span> <span class="kw">auto</span> find_1 = item_kind::armor;
	<span class="dt">const</span> <span class="kw">auto</span> find_2 = item_kind::junk;
	std::cout &lt;&lt; <span class="st">&quot;Our first find is &quot;</span> &lt;&lt; to_string(find_1)
		&lt;&lt; <span class="st">&quot;, our second find is&quot;</span> &lt;&lt; to_string(find_2) &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;
}</code></pre>
<p>The advantage of this approach over integer-constants is that we have our own type, which, among other things, implies that we can overload functions for it and, that it became harder to accidentially use a different integer that was supposed to mean something else where we wanted to know what kind of item our find is.</p>
<p>To show a real-live situation where types are used, we don't need to look far: From the first grade on pupils are forced by their teachers and parents to not throw away things like meters, seconds, liters, … when doing exercises for school and get ask questions like: “Three what? <a href="https://en.wikipedia.org/wiki/Bratwurst">Bratwürste</a>?” (Or at least the author of this text got this question). The reasoning is again that keeping this kind of information can easily expose a lot of errors in the used formulas or during calculation.</p>
<p>An dramatic example for what can happen if you do not use types is the <a href="https://en.wikipedia.org/wiki/Mars_Climate_Orbiter">Mars Climate Orbiter</a>: It got to close to the surface because one module incorrectly produced results in imperial measures, while another one expected those to be in a sane (=metric) unit-system. The lessons from this incident are:</p>
<ul>
<li>Never use the imperial system and allways use the metric system</li>
<li>Do your calculations with units, as you learned in first grade.</li>
</ul>
<p>Now, back to our loot: We want to be able to add further information too it, so that we can have different kinds of it.</p>
<p>Obviously each piece should have at least have name that describes it and a value in goldpieces. Carrying those informations arround manually by passing them around as additional arguments would however be very cumbersome. The good news is that C++ provides us a way to create a new type that is basically just a collection of different values: A <code>struct</code>:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> item {
	std::string name;
	<span class="dt">int</span> value; <span class="co">// some pieces might be so terrible that you have to pay people to take them</span>
	item_kind kind;
}; <span class="co">// note the &#39;;&#39;, it is important!</span></code></pre>
<p>This defines a new type <code>item</code> that will safe us from all the trouble by making sure that it contains all the information we might ever need. The syntactic requirements to create such a thing should be relatively obvious from the example: First you declare your intent to define a struct by writing <code>struct</code> followed by the name it should have; after that you declare all the variables it should hold by specifying their types and names inside a pair of braces and finally put a semicolon there. <strong>Do not forget that semicolon!</strong> This is probably the most common error that even advanced programmers make when it comes to defining simple types.</p>
<p>So how can we use that? Again, by just declaring a variable of that type and using it's members:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main() {
	<span class="kw">auto</span> find = item{};
	item.name = <span class="st">&quot;Sword of Doom&quot;</span>;
	item.value = <span class="dv">100&#39;000&#39;000</span>; <span class="co">// if we have a number with a lot of digits,</span>
	                          <span class="co">// we can increase readability like this</span>
	                          <span class="co">// by inserting some apostrophes</span>
	item.kind = item_kind::weapon;
	std::cout &lt;&lt; <span class="st">&quot;You just found a &quot;</span> &lt;&lt; item.name &lt;&lt; <span class="st">&quot; which is worth &quot;</span>
	          &lt;&lt; item.value &lt;&lt; <span class="st">&quot; golden coins!</span><span class="ch">\n</span><span class="st">&quot;</span>;
}</code></pre>
<p>Passing it to a function or defining a function that takes an item as argument is completely identical to how we did it up to now too:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// try to sell your item for the specified</span>
<span class="co">// amount of coins; negative offers mean</span>
<span class="co">// that you are willing to pay the merchant</span>
<span class="co">// for taking it</span>
<span class="dt">bool</span> sell(<span class="dt">const</span> item&amp; find, <span class="dt">int</span> offer) {
	<span class="co">// A merchant only buys if he get&#39;s an item for</span>
	<span class="co">// less than it is worth</span>
	<span class="kw">return</span> find.value &gt; offer;
}</code></pre>
<p>However, there is one problem: We haven't defined the default-values of the structs members, so what are those?</p>
<p>Well, the sad answer is “it depends”: The types of the standard-library will be initialized with an empty/zero state, but the build-in types like integers will not recieve that treatment and reading them results in <strong>undefined behavior</strong>! A first fix for that is to directly assign those variables a value:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> item {
	std::string name;
	<span class="dt">int</span> value = <span class="dv">0</span>;
	item_kind kind = item_kind::junk;
};</code></pre>
<p>For some types that really is all we need, but in our case it certainly is not optimal, because what kind should an item have by default (why junk?) and what value (why nothing?). Furthermore an empty name is not very convincing either.</p>
<p>For those more advanced cases, C++ offers a solution too: So called “constructors”.</p>
<p>Basically those are functions that create instances of the type in question. Some are created by default and may disappear if we define others. One of the examples for this is the implicitly created default-constructor that takes no arguments which we implicitly used above. It will disappear the moment we define any other constructor but can easily be brought back if we so desire. What we would like here is however for it to stay deleted and instead we want a constructor that takes all the requred arguments. Let's see how that works:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> item {
	<span class="co">// A constructor is a function that is declared INSIDE</span>
	<span class="co">// the struct to which it belongs. It has the same name</span>
	<span class="co">// as the struct and no explicit return-values:</span>
	item(<span class="dt">const</span> std::string&amp; name, <span class="dt">int</span> value, item_kind kind);
	std::string name;
	<span class="dt">int</span> value = <span class="dv">0</span>;
	item_kind kind = item_kind::junk;
};

<span class="co">// We could have defined it right inside the class, but let&#39;s put</span>
<span class="co">// it behind it, so we also know how to do that.</span>
<span class="co">//</span>
<span class="co">// Note that to do this, we have to specify that the &#39;function&#39; we</span>
<span class="co">// want to use is inside the struct item (this is somewhat similar</span>
<span class="co">// to specifyin the std:: when refering to stdlib-types, though</span>
<span class="co">// there are also quite a few differences):</span>
<span class="co">//</span>
<span class="co">// Also note again the missing return-type!</span>
item::item(<span class="dt">const</span> std::string&amp; n, <span class="dt">int</span> v, item_kind kind) {
	<span class="co">// note that we can refere to the structs members without</span>
	<span class="co">// specifying anything now, but we should make sure that</span>
	<span class="co">// our arguments are named different from them!</span>
	<span class="co">// For that purpose it is legal (though very questionable!)</span>
	<span class="co">// to give other names to the function arguments than in</span>
	<span class="co">// the declaration.</span>
	name = n;
	value = v;
	<span class="co">// if for some reason we have the same name or we just want</span>
	<span class="co">// to be explicit that we want to talk about members, we</span>
	<span class="co">// can just prepend &#39;this-&gt;&#39;. Why the arrow instead of a point?</span>
	<span class="co">// Well, because &#39;this&#39; is a very old feature with bad behavior.</span>
	<span class="co">// It is not a good thing that it is that way, but we have to accept it:</span>
	<span class="kw">this</span>-&gt;kind = kind; <span class="co">// the argument hides the member, so we can just use it.</span>
}</code></pre>
<p>This works great will do so most of the time, but for completeness sake, let's see what our constructor really does: It initializes members with the arguments that we passed it. This is a very common thing, so there is some special alternative syntax: for it:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">item::item(<span class="dt">const</span> std::string&amp; n, <span class="dt">int</span> v, item_kind kind): <span class="co">// note the colon</span>
	name{n}, <span class="co">// constructs the member name by copying the argument n</span>
	value{v},
	kind{kind} <span class="co">// Here we can actually ignore name-clashes to a certain degree</span>
{} <span class="co">// The constructor still needs a body, but quite often it can be empty</span></code></pre>
<p>The main-advantage of this method is that it allows us to controllthe actual construction of the member instead of having it default-constructed just so that we can reassign a new value to them. (This may seem irrelevant now, but we will come across types where this will really matter.)</p>
<p>Another advantage is that most experienced programmers will consider it cleaner and easier to understand at a glance.</p>
<p>There are however some traps:</p>
<ul>
<li>The members will always be initialized in the order in which they are declared inside the struct, not in the order that is used in the initialization-list (which is the name that these constructor-calls outside the body have).</li>
<li>The expressions to initialize a value may refer both to other struct-members as well as to the constructor arguments. <strong>Never</strong> refer to struct-members that are declared behind the member that you currently initialize, since that is a very bad case of <strong>undefined behavior</strong>.</li>
<li>The expressions may also be more complex than just copying a value, basically everything one wants to do can be done in them (this doesn't mean everything that can be done in them <em>should</em> be done in them).</li>
</ul>
<p>Some further examples:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> example_1 {
	<span class="co">// this is how you define a constructor inline:</span>
	example_1(<span class="dt">const</span> std::string&amp; str): str{str} {}
	std::string str;
};

<span class="kw">struct</span> example_2 {
	<span class="co">// we can also pass multiple arguments to the constructor,</span>
	<span class="co">// this will create a string that holds n occurences of c:</span>
	example_2(<span class="dt">char</span> c, std::size_t n): str(n, c) {}
	std::string str;
};


<span class="kw">struct</span> example_3 {
	<span class="co">// Mixed order: This specific instance will work,</span>
	<span class="co">// but don&#39;t do that!</span>
	example_3(<span class="dt">int</span> i1, <span class="dt">int</span> i2): i2{i2}, i1{i1} {}

	<span class="co">// This is undefined behavior because i2 is</span>
	<span class="co">// read before it is initialized. NEVER do that!!</span>
	<span class="co">//example_3(int i): i2{i}, i1{i2} {}</span>
	<span class="dt">int</span> i1;
	<span class="dt">int</span> i2;
};</code></pre>
<h2 id="drops-and-random-numbers">Drops and Random Numbers</h2>
<p>Since we have now defined how we would like to represent the games items, we need a list of them. For the meantime we don't want to change what items are available, so a global constant is perfectly fine here:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// just put this into the global scope:</span>
<span class="dt">const</span> <span class="kw">auto</span> items = std::vector&lt;item&gt;{
	<span class="co">// the language knows that we want to call the</span>
	<span class="co">// constructor here, so there is no need to</span>
	<span class="co">// type the name again and again:</span>
	{<span class="st">&quot;Cheap Sword&quot;</span>, <span class="dv">100</span>, item_kind::weapon},
	{<span class="st">&quot;Sword&quot;</span>, <span class="dv">500</span>, item_kind::weapon},
	{<span class="st">&quot;Sword of Doom&quot;</span>, <span class="dv">10000</span>, item_kind::weapon},
	{<span class="st">&quot;Mail&quot;</span>, <span class="dv">500</span>, item_kind::armor},
	{<span class="st">&quot;Necklace&quot;</span>, <span class="dv">5000</span>, item_kind::jewelry},
	{<span class="st">&quot;Dirt&quot;</span>, <span class="dv">0</span>, item_kind::junk},
	{<span class="st">&quot;toxic Dirt&quot;</span>, <span class="dv">-100</span>, item_kind::junk}
};</code></pre>
<p>Now we need a function that returns a random item:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">item random_item() {
	<span class="dt">const</span> <span class="kw">auto</span> item_index = ????
	<span class="kw">return</span> items[item_index];
}</code></pre>
<p>Obviously we need some way to get a random number. There are several ways to achieve that in C++ and most of them are bad for various reasons. Even though it may look a bit like overkill at first, we will use the right way from the beginning, because the supposedly simpler (because they are usually wrong) ways won't save us from learning the right way at some point, they just postpone it.</p>
<p>The very first thing we have to do in order to use the random-facilities is including the <code>&lt;random&gt;</code>-header. After that we will have a lot of partially hard to understand things at our hands, most of which we don't need now (this doesn't mean that it isn't usefull or good, it's just for more advanced tasks). What we should understand at first is that C++ separates the notions a random-number-generator and a random distribution. Now, what is the difference between those two?</p>
<p>A real-life example may be a good way to explain it: Say we want to pick a random number between one and three (1, 2 or 3), but we only have a coin to produce random bits (zero or one). In order to avoid bias when selecting a number we now have to think up an algorithm of how to throw the coin multiple times to select any of those three numbers with the same propability.</p>
<p>What we will do is to throw the coin to times and memorize the results. There are now four possiblities for the result:</p>
<ul>
<li>twice heads -&gt; we pick 1</li>
<li>twice tails -&gt; we pick 2</li>
<li>first head, then tail -&gt; we pick 3</li>
<li>first tail, then head -&gt; If we pick anything in this case, we will favor that, so we won't pick anything but redo the whole thing from the beginning with new random numbers.</li>
</ul>
<p>In this case, the coint serves as a random-number-generator, while our algorithm creates a distribution of random-numbers. Obviously a distribution needs access to a random-number-generator and has to be able to use it arbitrarily often.</p>
<p>C++ offers us both several random-number-generators as well as several distributions, for now it should be sufficient to know two of them:</p>
<ul>
<li><code>std::random_device</code> this random-number-generator produces unpredictable high-quality random numbers, but it may potentially be slow. For our purposes it is by far fast enough though, so we shouldn't worry about that.</li>
<li><code>std::uniform_int_distribution&lt;Integer&gt;</code> This distribution produces random integers of the specified type in a range that can be specified by the user, where every possible value will be choosen with the same likelyhood.</li>
</ul>
<p>So how do we use it? Basically we will create a variable of each type and use the distribution as a function that recieves the generator as the only argument. It may sound strange, but in C++ we can actually create types that behave like functions in some circumstances and this is one example:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;random&gt;</span>

<span class="dt">int</span> main() {
	<span class="co">// std::random_device is one of the</span>
	<span class="co">// few types in c++ that doesn&#39;t allow the creation</span>
	<span class="co">// of instances with &#39;auto name = type{};&#39;, so we</span>
	<span class="co">// have to do it like this:</span>
	std::random_device rd;
	<span class="co">// this will create random numbers between 23 and 42 inclusive.</span>
	<span class="co">// In other words: 23 and 42 may very well be created too:</span>
	<span class="kw">auto</span> dist = std::uniform_int_distribution&lt;<span class="dt">int</span>&gt;{<span class="dv">23</span>, <span class="dv">42</span>};
	std::cout &lt;&lt; dist(rd) &lt;&lt; <span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>;
}</code></pre>
<p>Calling this multiple times should yield different results, where each is equally likely.</p>
<p>In order to use this for our item-selection we will create a small helper-function that creates a random-index for a container of size <code>n</code>:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdint&gt;</span>

std::size_r random_index(std::size_t container_size) {
	std::random_device rd;
	<span class="co">// we need to decrement the container size, since it isn&#39;t a valid index itself!</span>
	<span class="kw">auto</span> dist = std::uniform_int_distribution&lt;std::size_t&gt;{<span class="dv">0</span>, container_size - <span class="dv">1u</span>};
	<span class="kw">return</span> dist(rd);
}</code></pre>
<p>After that we can implement our item-selection again:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">item random_item() {
	<span class="kw">return</span> items[random_index(items.size())];
}</code></pre>
<p>Putting everything that we have so far together into a program in which we kick in ten doors and loot everything of value that we find behind them, we get this:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;cstdint&gt;</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;random&gt;</span>
<span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>

<span class="kw">enum</span> <span class="kw">class</span> item_kind {
	armor,
	weapon,
	jewelry,
	junk
};

std::string to_string(<span class="dt">const</span> item_kind&amp; kind) {
	<span class="kw">if</span> (kind == item_kind::armor) {
		<span class="kw">return</span> <span class="st">&quot;armor&quot;</span>;
	} <span class="kw">else</span> <span class="kw">if</span> (kind == item_kind::weapon) {
		<span class="kw">return</span> <span class="st">&quot;weapon&quot;</span>;
	} <span class="kw">else</span> <span class="kw">if</span> (kind == item_kind::jewelry) {
		<span class="kw">return</span> <span class="st">&quot;jewelry&quot;</span>;
	} <span class="kw">else</span> <span class="kw">if</span> (kind == item_kind::junk) {
		<span class="kw">return</span> <span class="st">&quot;junk&quot;</span>;
	} <span class="kw">else</span> {
		std::cerr &lt;&lt; <span class="st">&quot;This should never happen!</span><span class="ch">\n</span><span class="st">&quot;</span>;
		std::terminate();
	}
}

<span class="kw">struct</span> item {
	item(<span class="dt">const</span> std::string&amp; name, <span class="dt">int</span> value, item_kind kind);
	std::string name;
	<span class="dt">int</span> value = <span class="dv">0</span>;
	item_kind kind = item_kind::junk;
};

item::item(<span class="dt">const</span> std::string&amp; n, <span class="dt">int</span> v, item_kind kind):
	name{n}, value{v}, kind{kind} {}

<span class="dt">const</span> <span class="kw">auto</span> items = std::vector&lt;item&gt;{
	{<span class="st">&quot;cheap Sword&quot;</span>, <span class="dv">100</span>, item_kind::weapon},
	{<span class="st">&quot;Sword&quot;</span>, <span class="dv">500</span>, item_kind::weapon},
	{<span class="st">&quot;Sword of Doom&quot;</span>, <span class="dv">10000</span>, item_kind::weapon},
	{<span class="st">&quot;Mail&quot;</span>, <span class="dv">500</span>, item_kind::armor},
	{<span class="st">&quot;Necklace&quot;</span>, <span class="dv">5000</span>, item_kind::jewelry},
	{<span class="st">&quot;Dirt&quot;</span>, <span class="dv">0</span>, item_kind::junk},
	{<span class="st">&quot;toxic Dirt&quot;</span>, <span class="dv">-100</span>, item_kind::junk}
};

std::size_t random_index(std::size_t container_size) {
	std::random_device rd;
	<span class="co">// we need to decrement the container size, since it isn&#39;t a valid index itself!</span>
	<span class="kw">auto</span> dist = std::uniform_int_distribution&lt;std::size_t&gt;{<span class="dv">0</span>, container_size - <span class="dv">1u</span>};
	<span class="kw">return</span> dist(rd);
}

item random_item() {
	<span class="kw">return</span> items[random_index(items.size())];
}

<span class="dt">int</span> main() {
	<span class="kw">auto</span> backpack = std::vector&lt;item&gt;{};
	<span class="kw">for</span> (<span class="kw">auto</span> i = <span class="dv">0u</span>; i &lt; <span class="dv">10u</span>; ++i) {
		std::cout &lt;&lt; <span class="st">&quot;Kicking in door &quot;</span> &lt;&lt; i &lt;&lt; <span class="st">&quot;...</span><span class="ch">\n</span><span class="st">&quot;</span>;
		<span class="dt">const</span> <span class="kw">auto</span> item = random_item();
		std::cout &lt;&lt; <span class="st">&quot;We found &#39;&quot;</span> &lt;&lt; item.name &lt;&lt; <span class="st">&quot;&#39; &quot;</span>;
		<span class="kw">if</span> (item.value &gt; <span class="dv">0</span>) {
			std::cout &lt;&lt; <span class="st">&quot;and loot it!</span><span class="ch">\n</span><span class="st">&quot;</span>;
			backpack.push_back(item);
		} <span class="kw">else</span> {
			std::cout &lt;&lt; <span class="st">&quot;and discard it because it isn&#39;t worth anything.</span><span class="ch">\n</span><span class="st">&quot;</span>;
		}
		std::cout &lt;&lt; <span class="st">&quot;We now have &quot;</span> &lt;&lt; backpack.size() &lt;&lt; <span class="st">&quot; item(s) in our backpack.</span><span class="ch">\n</span><span class="st">&quot;</span>;
	}
}</code></pre>
<hr/>
<section class="license">
	<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
		<img src="CC_BY_SA.png" height="31px" width="88px" alt="CC-BY-SA" align="left" hspace="2px"/>
	</a>
	This work from Florian Weber is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br/>
</section>
</body>
</html>
